#!/usr/bin/env node

const { PrismaClient } = require("@prisma/client");
const bcrypt = require("bcryptjs");
const fs = require("fs");
const path = require("path");

const prisma = new PrismaClient();

// Get environment from command line args
const env = process.argv.includes("--env=test") ? "test" : "development";

console.log(`üå± Seeding database for ${env} environment...`);

async function main() {
  try {
    // Clear existing data (optional - comment out if you want to preserve data)
    if (env === "test") {
      console.log("üßπ Clearing existing data for test environment...");
      await clearDatabase();
    }

    // Seed superadmin user
    await seedSuperAdmin();

    // Seed admin users
    await seedAdminUsers();

    // Seed regular users
    await seedRegularUsers();

    // Seed categories
    await seedCategories();

    // Seed interview templates
    await seedInterviewTemplates();

    // Seed problems from existing data
    await seedProblemsFromData();

    // Seed MCQ questions from existing data
    await seedMCQsFromData();

    // Seed sample exams
    await seedSampleExams();

    // Seed global configs
    await seedGlobalConfigs();

    console.log("‚úÖ Database seeding completed successfully!");
  } catch (error) {
    console.error("‚ùå Error seeding database:", error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

async function clearDatabase() {
  const tables = [
    "exam_question_results",
    "exam_sessions",
    "exam_results",
    "exam_questions",
    "exams",
    "interview_feedback",
    "interview_answers",
    "interview_questions",
    "mock_interviews",
    "interview_templates",
    "user_progress",
    "submissions",
    "mcq_questions",
    "problems",
    "feedback",
    "categories",
    "global_configs",
    "settings",
    "users",
  ];

  for (const table of tables) {
    await prisma.$executeRawUnsafe(`DELETE FROM "${table}"`);
  }
}

async function seedSuperAdmin() {
  console.log("üëë Creating superadmin user...");

  const hashedPassword = await bcrypt.hash("superadmin123", 12);

  await prisma.user.upsert({
    where: { email: "superadmin@interview-platform.com" },
    update: {},
    create: {
      email: "superadmin@interview-platform.com",
      name: "Super Admin",
      password: hashedPassword,
      provider: "email",
      role: "superadmin",
      isActive: true,
      emailVerified: true,
      profileCompleted: true,
      firstName: "Super",
      lastName: "Admin",
    },
  });
}

async function seedAdminUsers() {
  console.log("üë®‚Äçüíº Creating admin users...");

  const adminUsers = [
    {
      email: "admin@interview-platform.com",
      name: "Platform Admin",
      password: "admin123",
      firstName: "Platform",
      lastName: "Admin",
    },
    {
      email: "content@interview-platform.com",
      name: "Content Manager",
      password: "content123",
      firstName: "Content",
      lastName: "Manager",
    },
  ];

  for (const user of adminUsers) {
    const hashedPassword = await bcrypt.hash(user.password, 12);

    await prisma.user.upsert({
      where: { email: user.email },
      update: {},
      create: {
        email: user.email,
        name: user.name,
        password: hashedPassword,
        provider: "email",
        role: "admin",
        isActive: true,
        emailVerified: true,
        profileCompleted: true,
        firstName: user.firstName,
        lastName: user.lastName,
      },
    });
  }
}

async function seedRegularUsers() {
  console.log("üë• Creating sample users...");

  const users = [
    {
      email: "john.doe@example.com",
      name: "John Doe",
      password: "password123",
      firstName: "John",
      lastName: "Doe",
    },
    {
      email: "jane.smith@example.com",
      name: "Jane Smith",
      password: "password123",
      firstName: "Jane",
      lastName: "Smith",
    },
    {
      email: "bob.wilson@example.com",
      name: "Bob Wilson",
      password: "password123",
      firstName: "Bob",
      lastName: "Wilson",
    },
  ];

  for (const user of users) {
    const hashedPassword = await bcrypt.hash(user.password, 12);

    await prisma.user.upsert({
      where: { email: user.email },
      update: {},
      create: {
        email: user.email,
        name: user.name,
        password: hashedPassword,
        provider: "email",
        role: "user",
        isActive: true,
        emailVerified: true,
        profileCompleted: true,
        firstName: user.firstName,
        lastName: user.lastName,
      },
    });
  }
}

async function seedCategories() {
  console.log("üìÇ Creating categories...");

  const categories = [
    {
      name: "Arrays",
      type: "question",
      description: "Array-based problems and questions",
      color: "#3B82F6",
      icon: "üìä",
    },
    {
      name: "Strings",
      type: "question",
      description: "String manipulation problems",
      color: "#10B981",
      icon: "üìù",
    },
    {
      name: "Algorithms",
      type: "question",
      description: "Algorithm problems and concepts",
      color: "#F59E0B",
      icon: "‚ö°",
    },
    {
      name: "Data Structures",
      type: "question",
      description: "Data structure problems",
      color: "#8B5CF6",
      icon: "üèóÔ∏è",
    },
    {
      name: "Java",
      type: "question",
      description: "Java programming questions",
      color: "#EF4444",
      icon: "‚òï",
    },
    {
      name: "JavaScript",
      type: "question",
      description: "JavaScript programming questions",
      color: "#F97316",
      icon: "üü®",
    },
    {
      name: "Python",
      type: "question",
      description: "Python programming questions",
      color: "#06B6D4",
      icon: "üêç",
    },
    {
      name: "Frontend Development",
      type: "interview",
      description: "Frontend development interviews",
      color: "#EC4899",
      icon: "üé®",
    },
    {
      name: "Backend Development",
      type: "interview",
      description: "Backend development interviews",
      color: "#84CC16",
      icon: "‚öôÔ∏è",
    },
    {
      name: "Full Stack Development",
      type: "interview",
      description: "Full stack development interviews",
      color: "#6366F1",
      icon: "üîÑ",
    },
  ];

  for (const category of categories) {
    await prisma.category.upsert({
      where: { name: category.name },
      update: {},
      create: category,
    });
  }
}

async function seedInterviewTemplates() {
  console.log("üìã Creating interview templates...");

  const templates = [
    {
      name: "Frontend Developer Interview",
      description:
        "Comprehensive frontend development interview covering HTML, CSS, JavaScript, and modern frameworks",
      duration: 60,
      difficulty: "Medium",
      category: "Frontend Development",
      companies: JSON.stringify(["Google", "Facebook", "Netflix", "Airbnb"]),
    },
    {
      name: "Backend Developer Interview",
      description:
        "Backend development interview focusing on APIs, databases, and server-side technologies",
      duration: 90,
      difficulty: "Hard",
      category: "Backend Development",
      companies: JSON.stringify(["Amazon", "Microsoft", "Uber", "Stripe"]),
    },
    {
      name: "Full Stack Developer Interview",
      description:
        "Complete full-stack development interview covering both frontend and backend technologies",
      duration: 120,
      difficulty: "Hard",
      category: "Full Stack Development",
      companies: JSON.stringify(["Netflix", "Airbnb", "Uber", "Spotify"]),
    },
  ];

  for (const template of templates) {
    await prisma.interviewTemplate.upsert({
      where: { name: template.name },
      update: {},
      create: template,
    });
  }
}

async function seedProblemsFromData() {
  console.log("üíª Seeding problems from existing data...");

  const dataDir = path.join(__dirname, "../data/seeds");
  const languages = ["java", "javascript", "python"];

  for (const language of languages) {
         const problemsFiles = [
       path.join(dataDir, language, `${language}-problems.json`),
       path.join(dataDir, language, `${language}-advanced-problems.json`),
     ];

         for (const problemsFile of problemsFiles) {
       if (fs.existsSync(problemsFile)) {
         try {
           const data = JSON.parse(fs.readFileSync(problemsFile, "utf8"));

        for (const concept of data.concepts || []) {
          for (const problem of concept.problems || []) {
            const problemData = {
              title: problem.title,
              description: problem.description,
              difficulty: problem.difficulty || "medium",
              category: concept.name || language,
              subject: language.charAt(0).toUpperCase() + language.slice(1),
              topic: concept.name,
              testCases: JSON.stringify(problem.testCases || []),
              solution: problem.solution || "",
              hints: JSON.stringify(problem.hints || []),
              tags: JSON.stringify(problem.tags || []),
              companies: JSON.stringify(problem.companies || []),
            };

            await prisma.problem.upsert({
              where: { title: problemData.title },
              update: {},
              create: problemData,
            });
          }
        }
                   console.log(`‚úÖ Seeded ${path.basename(problemsFile)}`);
         } catch (error) {
           console.error(`‚ùå Error seeding ${path.basename(problemsFile)}:`, error.message);
         }
       }
     }
}

async function seedMCQsFromData() {
  console.log("‚ùì Seeding MCQ questions from existing data...");

  const dataDir = path.join(__dirname, "../data/seeds");
  const languages = ["java", "javascript", "python"];

  for (const language of languages) {
         const mcqFiles = [
       `${language}-mcq.json`,
       `${language}-basics-mcq.json`,
       `${language}-oop-mcq.json`,
       `${language}-advanced.json`,
     ];

    for (const mcqFile of mcqFiles) {
      const filePath = path.join(dataDir, language, mcqFile);

      if (fs.existsSync(filePath)) {
        try {
          const data = JSON.parse(fs.readFileSync(filePath, "utf8"));

          for (const concept of data.concepts || []) {
            for (const question of concept.questions || []) {
              // Handle different MCQ data formats
              let options, correctAnswerIndex;

              if (Array.isArray(question.options)) {
                // Java format: options is array, correctAnswer is string
                options = question.options;
                const correctAnswer = question.correctAnswer;
                correctAnswerIndex = options.findIndex(
                  (option) => option === correctAnswer
                );
                if (correctAnswerIndex === -1) {
                  correctAnswerIndex = 0;
                }
              } else if (typeof question.options === "string") {
                // JavaScript/Python format: options is JSON string, correctAnswer is index
                try {
                  options = JSON.parse(question.options);
                  correctAnswerIndex = question.correctAnswer || 0;
                } catch (e) {
                  console.error(
                    `Error parsing options for question: ${question.question}`
                  );
                  options = [];
                  correctAnswerIndex = 0;
                }
              } else {
                options = [];
                correctAnswerIndex = 0;
              }

              const mcqData = {
                question: question.question,
                options: JSON.stringify(options),
                correctAnswer: correctAnswerIndex,
                explanation: question.explanation || "",
                category: concept.name || language,
                subject: language.charAt(0).toUpperCase() + language.slice(1),
                topic: concept.name,
                difficulty:
                  question.difficulty || concept.difficulty || "medium",
                tags: JSON.stringify(question.tags || []),
                companies: JSON.stringify(question.companies || []),
              };

              await prisma.mCQQuestion.upsert({
                where: { question: mcqData.question },
                update: {},
                create: mcqData,
              });
            }
          }
          console.log(`‚úÖ Seeded ${mcqFile}`);
        } catch (error) {
          console.error(`‚ùå Error seeding ${mcqFile}:`, error.message);
        }
      }
    }
  }
}

async function seedSampleExams() {
  console.log("üìù Creating sample exams...");

  const exams = [
    {
      title: "JavaScript Fundamentals",
      description:
        "Test your knowledge of JavaScript basics including variables, functions, and control structures",
      duration: 30,
      difficulty: "Easy",
      category: "Programming",
      targetRole: "Frontend Developer",
      questionTypes: "MCQ",
      totalQuestions: 10,
      passingScore: 70,
    },
    {
      title: "Data Structures & Algorithms",
      description:
        "Comprehensive test covering arrays, linked lists, trees, and basic algorithms",
      duration: 60,
      difficulty: "Medium",
      category: "Computer Science",
      targetRole: "Software Engineer",
      questionTypes: "Mixed",
      totalQuestions: 20,
      passingScore: 75,
    },
    {
      title: "System Design",
      description:
        "Advanced system design concepts including scalability, distributed systems, and architecture patterns",
      duration: 90,
      difficulty: "Hard",
      category: "System Design",
      targetRole: "Senior Developer",
      questionTypes: "Mixed",
      totalQuestions: 15,
      passingScore: 80,
    },
  ];

  for (const exam of exams) {
    await prisma.exam.upsert({
      where: { title: exam.title },
      update: {},
      create: exam,
    });
  }
}

async function seedGlobalConfigs() {
  console.log("‚öôÔ∏è Creating global configurations...");

  const configs = [
    {
      key: "app_name",
      value: "MyMentor",
      type: "string",
      description: "Application name",
    },
    {
      key: "app_version",
      value: "1.0.0",
      type: "string",
      description: "Application version",
    },
    {
      key: "max_problems_per_page",
      value: "20",
      type: "number",
      description: "Maximum problems to show per page",
    },
    {
      key: "max_mcq_per_page",
      value: "20",
      type: "number",
      description: "Maximum MCQ questions to show per page",
    },
    {
      key: "enable_code_execution",
      value: "true",
      type: "boolean",
      description: "Enable code execution feature",
    },
    {
      key: "default_exam_duration",
      value: "60",
      type: "number",
      description: "Default exam duration in minutes",
    },
  ];

  for (const config of configs) {
    await prisma.globalConfig.upsert({
      where: { key: config.key },
      update: {},
      create: config,
    });
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
