{
  "language": "JavaScript",
  "category": "JavaScript",
  "concepts": [
    {
      "name": "Advanced Algorithms",
      "difficulty": "hard",
      "problems": [
        {
          "id": "js_deep_clone",
          "title": "Deep Clone Object",
          "description": "Implement a function that creates a deep clone of a JavaScript object. The function should handle nested objects, arrays, and primitive values.\n\nInput: A JavaScript object (can be nested)\nOutput: A deep clone of the input object\n\nExample:\nInput: { a: 1, b: { c: 2, d: [3, 4] } }\nOutput: { a: 1, b: { c: 2, d: [3, 4] } }\n\nNote: The output should be completely independent of the input object.",
          "testCases": [
            {
              "input": "{ a: 1, b: { c: 2, d: [3, 4] } }",
              "output": "{ a: 1, b: { c: 2, d: [3, 4] } }",
              "description": "Basic nested object with array"
            },
            {
              "input": "[1, 2, { a: 3, b: [4, 5] }]",
              "output": "[1, 2, { a: 3, b: [4, 5] }]",
              "description": "Array with nested objects"
            },
            {
              "input": "{ a: null, b: undefined, c: 'string', d: 123 }",
              "output": "{ a: null, b: undefined, c: 'string', d: 123 }",
              "description": "Mixed primitive types"
            }
          ],
          "solution": "function deepClone(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n  \n  if (obj instanceof Array) {\n    return obj.map(item => deepClone(item));\n  }\n  \n  if (typeof obj === 'object') {\n    const cloned = {};\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cloned[key] = deepClone(obj[key]);\n      }\n    }\n    return cloned;\n  }\n}",
          "hints": [
            "Check if the value is a primitive or object",
            "Handle special cases like Date objects",
            "Recursively clone nested objects and arrays",
            "Use hasOwnProperty to avoid prototype properties"
          ],
          "tags": ["objects", "recursion", "algorithms"],
          "companies": ["Google", "Facebook", "Amazon"],
          "difficulty": "hard"
        },
        {
          "id": "js_debounce",
          "title": "Debounce Function",
          "description": "Implement a debounce function that delays the execution of a function until after a specified delay has elapsed since the last time it was invoked.\n\nInput: A function and a delay time in milliseconds\nOutput: A debounced version of the function\n\nExample:\nconst debouncedSearch = debounce(searchAPI, 300);\n// If called multiple times within 300ms, only the last call executes",
          "testCases": [
            {
              "input": "function test() { return 'executed'; }, 100",
              "output": "function that delays execution",
              "description": "Basic debounce functionality"
            },
            {
              "input": "function test(x) { return x * 2; }, 200",
              "output": "function that delays execution",
              "description": "Debounce with parameters"
            }
          ],
          "solution": "function debounce(func, delay) {\n  let timeoutId;\n  \n  return function(...args) {\n    clearTimeout(timeoutId);\n    \n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}",
          "hints": [
            "Use setTimeout to delay execution",
            "Clear the previous timeout when function is called again",
            "Use apply to preserve the context and pass arguments",
            "Return a new function that wraps the original"
          ],
          "tags": ["functions", "timing", "closures"],
          "companies": ["Google", "Facebook", "Netflix"],
          "difficulty": "medium"
        }
      ]
    },
    {
      "name": "Event System",
      "difficulty": "hard",
      "problems": [
        {
          "id": "js_event_emitter",
          "title": "Event Emitter",
          "description": "Implement a simple EventEmitter class that can subscribe to and emit events.\n\nMethods to implement:\n- on(event, callback): Subscribe to an event\n- off(event, callback): Unsubscribe from an event\n- emit(event, ...args): Emit an event with arguments\n\nExample:\nconst emitter = new EventEmitter();\nemitter.on('message', (msg) => console.log(msg));\nemitter.emit('message', 'Hello World'); // logs: Hello World",
          "testCases": [
            {
              "input": "on('test', (x) => x), emit('test', 'hello')",
              "output": "callback executed with 'hello'",
              "description": "Basic event subscription and emission"
            },
            {
              "input": "on('test', cb1), on('test', cb2), emit('test', 'data')",
              "output": "both callbacks executed",
              "description": "Multiple subscribers to same event"
            }
          ],
          "solution": "class EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  \n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  }\n  \n  off(event, callback) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter(cb => cb !== callback);\n    }\n  }\n  \n  emit(event, ...args) {\n    if (this.events[event]) {\n      this.events[event].forEach(callback => callback(...args));\n    }\n  }\n}",
          "hints": [
            "Store events and callbacks in an object",
            "Use arrays to store multiple callbacks for the same event",
            "Use rest parameters to handle multiple arguments",
            "Filter out the specific callback when unsubscribing"
          ],
          "tags": ["events", "classes", "callbacks"],
          "companies": ["Google", "Microsoft", "Amazon"],
          "difficulty": "medium"
        }
      ]
    }
  ]
}
